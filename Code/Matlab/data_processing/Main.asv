clc
clear

%% Add important paths
addpath('C:\Morteza\Toolboxes\Fieldtrip\fieldtrip-20231127')
addpath('C:\Morteza\Toolboxes\Fieldtrip\fieldtrip-20231127\fileio')

%% All signals from all runs concatenated (it takes time!)
subject_id = 7;
sessions   = 4;

%%
% [All_EEG, All_EEG_time, ...
%     All_EMG, All_EMG_time, ...
%     All_Experiment, All_Experiment_time] ...
%     = runs_concatenated(subject_id, sessions);


%% Define and Add events

% outputs: All_EEG, All_EEG_time, All_EMG, All_EMG_time, All_Exp, All_Exp_time
% All_Experiment: 
% [angle; ref_trj; mappedPressure; Preference; force; auditory_input]
outputid = [2 3 4 5 6]; % which output you want to have after calling runs_concatenated function
[~, All_EEG_time, ~, ~, All_Experiment, All_Experiment_time] ...
    = runs_concatenated(subject_id, sessions, outputid);
% plot(All_Experiment_time, All_Experiment(5,:))
% hold on
% xline(All_Experiment_time(start_beep), 'Color', 'g', 'LineStyle','--')
% xline(All_Experiment_time(finish_beep), 'Color', 'r', 'LineStyle','--')

%%



%%
% chanlocs = loadbvef('GACS-64_REF.bvef');
% save('chanlocs.mat', 'chanlocs')


% initialize EEGLAB 
if ~exist('ALLCOM','var')
	eeglab;
end

% initialize fieldtrip without adding alternative files to path 
% assuming FT is on your path already or is added via EEGlab plugin manager
global ft_default
ft_default.toolbox.signal = 'matlab';  % can be 'compat' or 'matlab'
ft_default.toolbox.stats  = 'matlab';
ft_default.toolbox.image  = 'matlab';
ft_defaults % this sets up the FieldTrip path


%% [OPTIONAL] check the .xdf data to explore the structure
ftPath      = fileparts(which('ft_defaults')); 
addpath(fullfile(ftPath, 'external','xdf')); 
xdfPath     = ['C:\Morteza\Analysis\ANSYMB2024\data\0_source_data\sub-7\', ...
    'ses-S001\eeg\sub-7_ses-S001_task-Default_run-001_eeg.xdf']; % enter full path to your .xdf file 

% load .xdf data to check what is in there
streams         = load_xdf(xdfPath);
streamnames     = cellfun(@(x) x.info.name, streams, 'UniformOutput', 0)' % will display names of streams contained in .xdf

% display names of all channels in the .xdf data
for Si = 1:numel(streamnames)
    if isfield( streams{Si}.info.desc, 'channels')
        channelnames    = cellfun(@(x) x.label, streams{Si}.info.desc.channels.channel, 'UniformOutput', 0)'
    end
end


%% [OPTIONAL] enter metadata about the data set, data modalities, and participants

% information about the eeg recording system 
% will be saved in BIDS-folder/sub-XX/[ses-XX]/eeg/*_eeg.json and *_coordsystem.json
% see "https://bids-specification.readthedocs.io/en/stable/04-modality-specific-files/03-electroencephalography.html#:~:text=MAY%20be%20specified.-,Sidecar%20JSON%20(*_eeg.json),-Generic%20fields%20MUST"
% and "https://bids-specification.readthedocs.io/en/stable/04-modality-specific-files/03-electroencephalography.html#:~:text=after%20the%20recording.-,Coordinate%20System%20JSON,-(*_coordsystem.json"
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
eegInfo     = [];
% eegInfo.coordsystem.EEGCoordinateSystem     = 'enter the name of your coordinate system'; % only needed when you share eloc
% eegInfo.coordsystem.EEGCoordinateUnits      = 'enter the unit of your coordinate system'; % only needed when you share eloc
% eegInfo.coordsystem.EEGCoordinateSystemDescription = 'enter description of your coordinate system'; % only needed when you share eloc
eegInfo.eeg.SamplingFrequency               = 500; % nominal sampling frequency  
                               


%% Import data

% iterate over sessions to import xdf files one by one
% full path to your study folder  
studyFolder   = 'C:\Morteza\Analysis\ANSYMB2024\data';     

% replace with names of your sessions (if there are no multiple sessions, 
% remove confg.ses and the session loop in the following)
sessionNames  = {'S001', 'S002', 'S003', 'S004'};             


% loop over sessions 
for session = 1:length(sessionNames)
    
    config                        = [];  % reset for each loop
    config.bids_target_folder     = 'C:\Morteza\Analysis\ANSYMB2024\data\1_BIDS_data';  % required, replace with the folder where you want to store your bids data
    
    config.filename               = ...
        fullfile(['C:\Morteza\Analysis\ANSYMB2024\data\0_source_data\sub-', ...
        num2str(subject_id),'\ses-', sessionNames{session}, ...
        '\eeg\sub-', num2str(subject_id), '_ses-', sessionNames{session}, ...
        '_task-Default_run-001_eeg.xdf']);    % required, replace with your xdf file full path
    
    % config.eeg.chanloc            = ...
    %     fullfile('C:\Morteza\Analysis\ANSYMB2024\Code\data_processing\chanlocs.ced');   % optional, if you have electrode location file, replace with the full path to the file. 
    
    config.task                   = 'KneeSwingingwithExo';  % optional, replace with your task name
    config.subject                = subject_id;  % required
    config.session                = sessionNames{session}; % optional
    config.overwrite              = 'on'; % optional
    
    config.eeg.stream_name        = 'LiveAmpSN-102108-1125'; % required, replace with the unique keyword in your eeg stream in the .xdf file
    
    %------------------------------------------------------------------
    
    % config.motion.streams{1}.xdfname            = 'YourStreamNameInXDF'; % replace with name of the stream corresponding to the first tracking system
    % config.motion.streams{1}.bidsname           = tracking_systems{1};  % a comprehensible name to represent the tracking system 
    % config.motion.streams{1}.tracked_points     = 'headRigid';          % name of the point that is being tracked in the tracking system, the keyword has to be containted in the channel name (see "bemobil_bids_motionconvert")
    % config.motion.streams{1}.tracked_points_anat= 'head';               % example of how the tracked point can be renamed to body part name for metadata
    % 
    % % names of position and quaternion channels in each stream
    % config.motion.streams{1}.positions.channel_names    = {'headRigid_Rigid_headRigid_X';  'headRigid_Rigid_headRigid_Y' ; 'headRigid_Rigid_headRigid_Z' };
    % config.motion.streams{1}.quaternions.channel_names  = {'headRigid_Rigid_headRigid_quat_W';'headRigid_Rigid_headRigid_quat_Z';...
    %                                                        'headRigid_Rigid_headRigid_quat_X';'headRigid_Rigid_headRigid_quat_Y'};
    % 
    % config.motion.streams{2}.xdfname            = 'YourStreamNameInXDF2';
    % config.motion.streams{2}.bidsname           = tracking_systems{2};
    % config.motion.streams{2}.tracked_points     = {'Rigid1', 'Rigid2', 'Rigid3', 'Rigid4'}; % example when there are multiple points tracked by the system
    % config.motion.streams{2}.positions.channel_names = {'Rigid1_X', 'Rigid2_X', 'Rigid3_X', 'Rigid4_X';... % each column is one tracked point and rows are different coordinates
    %                                                     'Rigid1_Y', 'Rigid2_Y', 'Rigid3_Y', 'Rigid4_Y';...
    %                                                     'Rigid1_Z', 'Rigid2_Z', 'Rigid3_Z', 'Rigid4_Z'};
    % config.motion.streams{2}.quaternions.channel_names = {'Rigid1_A', 'Rigid2_A', 'Rigid3_A', 'Rigid4_A';...
    %                                                     'Rigid1_B', 'Rigid2_B', 'Rigid3_B', 'Rigid4_B';...
    %                                                     'Rigid1_C', 'Rigid2_C', 'Rigid3_C', 'Rigid4_C'; ...
    %                                                     'Rigid1_D', 'Rigid2_D', 'Rigid3_D', 'Rigid4_D'};
    % 

    % bemobil_xdf2bids(config, ...
    %     'general_metadata', generalInfo,...
    %     'participant_metadata', subjectInfo,...
    %     'motion_metadata', motionInfo, ...
    %     'eeg_metadata', eegInfo);

    bemobil_xdf2bids(config, ...
        'eeg_metadata', eegInfo);
end


fclose all;


%% configuration for bemobil bids2set
%----------------------------------------------------------------------
config.set_folder               = fullfile(studyFolder,'2_raw-EEGLAB');
config.session_names            = sessionNames;

% config.other_data_types = {'motion'};  % specify which other data type than eeg is there (only 'motion' and 'physio' supported atm)
bemobil_bids2set(config);


%% Configuration of the BeMoBIL pipeline
bemobil_config = BeMoBIL_Configuration();

% enter all subjects to process here (you can split it up in more MATLAB instances if you have more CPU power and RAM)
subjects = 7; 

% set to 1 if all files should be computed, independently of whether they are present on disk or not
force_recompute = 0; 



%% processing loop

for subject = subjects
    
    %% prepare filepaths and check if already done
    
	disp(['Subject #' num2str(subject)]);
    
	STUDY = []; CURRENTSTUDY = 0; ALLEEG = [];  CURRENTSET=[]; EEG=[]; EEG_interp_avref = []; EEG_single_subject_final = [];
	
	input_filepath = [bemobil_config.study_folder bemobil_config.raw_EEGLAB_data_folder bemobil_config.filename_prefix num2str(subject)];
	output_filepath = [bemobil_config.study_folder bemobil_config.single_subject_analysis_folder bemobil_config.filename_prefix num2str(subject)];
	
	try
		% load completely processed file
		EEG_single_subject_final = pop_loadset('filename', [ bemobil_config.filename_prefix num2str(subject)...
			'_' bemobil_config.single_subject_cleaned_ICA_filename], 'filepath', output_filepath);
    catch
        disp('...failed. Computing now.')
	end
	
	if ~force_recompute && exist('EEG_single_subject_final','var') && ~isempty(EEG_single_subject_final)
		clear EEG_single_subject_final
		disp('Subject is completely preprocessed already.')
		continue
    end

	%% load data in EEGLAB .set structure
    % make sure the data is stored in double precision, large datafiles are supported, no memory mapped objects are
    % used but data is processed locally, and two files are used for storing sets (.set and .fdt)
	try 
        pop_editoptions('option_saveversion6', 0, 'option_single', 0, 'option_memmapdata', 0, 'option_savetwofiles', 1, 'option_storedisk', 0);
    catch
        warning('Could NOT edit EEGLAB memory options!!'); 
    end
    
    % load files that were created from xdf to BIDS to EEGLAB
    EEG = pop_loadset('filename',[ bemobil_config.filename_prefix num2str(subject) '_' bemobil_config.merged_filename],'filepath',input_filepath);
    

    %% Load channels location file
    EEG = pop_chanedit(EEG,'load', 'C:\Morteza\Analysis\ANSYMB2024\Code\data_processing\chanlocs.ced');

    %% Remove acceleration (ACC) channels
    ALLEEG.chanlocs(65:67) = [];
    ALLEEG.nbchan = 64;
    ALLEEG.data(65:67, :) = [];

    EEG.chanlocs(65:67) = [];
    EEG.nbchan = 64;
    EEG.data(65:67, :) = [];

    %% Define and Add events
    % Compute latency values

    start_beep = find(diff(All_Experiment(6, :)) == 1);
    start_beep(1:6) = [];
    start_beep_time_Expdata = All_Experiment_time(start_beep);
    start_beep_indx_EEG = ...
        knnsearch(All_EEG_time', start_beep_time_Expdata');
    start_beep_latency_EEG = EEG.times(start_beep_indx_EEG); % time unit: milisecond
    
    pressure_change_time_Expdata = All_Experiment_time(start_beep) - 2;
    pressure_change_indx_EEG = ...
        knnsearch(All_EEG_time', pressure_change_time_Expdata');
    pressure_change_latency_EEG = EEG.times(pressure_change_indx_EEG); % time unit: milisecond
    
    finish_beep = find(diff(All_Experiment(6, :)) == -1);
    finish_beep(1:6) = [];
    finish_beep_time_Expdata = All_Experiment_time(finish_beep);
    finish_beep_indx_EEG = ...
        knnsearch(All_EEG_time', finish_beep_time_Expdata');
    finish_beep_latency_EEG = EEG.times(finish_beep_indx_EEG); % time unit: milisecond
    

    % Preallocate the memory for score_change_latency_EEG
    score_press_latency_EEG = zeros(1, numel(start_beep));
    
    % Create an interpolation function for EEG times
    eeg_time_interpolant = griddedInterpolant(All_EEG_time, 1:numel(All_EEG_time), 'nearest');
    
    for i = 1:numel(start_beep)-1
        % Get the segment of Expdata_temp and Exptime_temp
        Expdata_temp = All_Experiment(4, finish_beep(i):start_beep(i+1));
        Exptime_temp = All_Experiment_time(1, finish_beep(i):start_beep(i+1));
    
        % Find the index where score change occurs
        score_press_indx = find(abs(Expdata_temp - Expdata_temp(1)) >= 1, 1);
    
        if ~isempty(score_press_indx) % score changed
            score_press_time_Expdata = Exptime_temp(score_press_indx);
        else % score didn't change, assume 2 seconds after finish_beep
            score_press_time_Expdata = All_Experiment_time(finish_beep(i)) + 2;
        end
    
        % Use the interpolation function to find the closest EEG index
        score_press_indx_EEG = round(eeg_time_interpolant(score_press_time_Expdata));
    
        % Calculate latency
        score_press_latency_EEG(i) = EEG.times(score_press_indx_EEG);
    end
    
    % for the last trial
    % Get the segment of Expdata_temp and Exptime_temp
    Expdata_temp = All_Experiment(4, finish_beep(end):end);
    Exptime_temp = All_Experiment_time(1, finish_beep(end):end);
    
    % Find the index where score change occurs
    score_press_indx = find(abs(Expdata_temp - Expdata_temp(1)) >= 1, 1);
    
    if ~isempty(score_press_indx) % score changed
        score_press_time_Expdata = Exptime_temp(score_press_indx);
    else % score didn't change, assume 2 seconds after finish_beep
        score_press_time_Expdata = All_Experiment_time(finish_beep(end)) + 2;
    end
    
    % Use the interpolation function to find the closest EEG index
    score_press_indx_EEG = round(eeg_time_interpolant(score_press_time_Expdata));
    
    % Calculate latency
    score_press_latency_EEG(end) = EEG.times(score_press_indx_EEG);
    
    
    %% Define and Add Events: Import Trials information
    Trials = cell(1, numel(start_beep));
    for i = 1:numel(Trials)
        Trials{1, i}.Pressure = All_Experiment(3, start_beep(1, i));
        if i ~= numel(Trials)
            Trials{1, i}.Score = All_Experiment(4, start_beep(1, i+1));
        else
            Trials{1, i}.Score = All_Experiment(4, end);
        end
    end
    

    %% Define and Add Events: add pressure change events
    type = repmat({'PC_Pressure_Change'}, 1, numel(pressure_change_latency_EEG));
    latency = pressure_change_latency_EEG;
    desc1 = cell(1, numel(pressure_change_latency_EEG)); % {P(i-1), P(i), Trial}
    for i = 1:length(desc1)
        if i~=1
            desc1{1, i} = {Trials{1, i-1}.Pressure, Trials{1, i}.Pressure, i};
        else
            indx_temp = knnsearch(All_Experiment_time', pressure_change_time_Expdata(1) - 0.1);
            desc1{1, 1} = {All_Experiment(3, indx_temp), Trials{1, i}.Pressure, i};
        end
    end
    
    desc = desc1;
    
    %% Define and Add Events: add start beep events
    type = [type, repmat({'SB_Start_Beep'}, 1, numel(start_beep))];
    latency = [latency, start_beep_latency_EEG];
    desc = [desc, desc1];
    
    %% Define and Add Events: add finish beep events
    type = [type, repmat({'FB_Finish_Beep'}, 1, numel(finish_beep))];
    latency = [latency, finish_beep_latency_EEG];
    desc = [desc, desc1];
    
    % %% Define and Add Events: add score change events
    % type = [type, repmat({'SP_Score_Press'}, 1, numel(score_press_latency_EEG))];
    % latency = [latency, score_press_latency_EEG]/1000; % in second
    % desc2 = cell(1, numel(score_press_latency_EEG)); % {P(i-1), P(i), Trial}
    % for i = 1:length(desc2)
    %     if i~=1
    %         desc2{1, i} = {Trials{1, i-1}.Pressure, Trials{1, i}.Pressure,Trials{1, i-1}.Score,Trials{1, i}.Score, i};
    %     else
    %         indx_temp = knnsearch(All_Experiment_time', pressure_change_time_Expdata(1) - 0.1);
    %         desc2{1, 1} = {All_Experiment(3, indx_temp), Trials{1, i}.Pressure, All_Experiment(4, indx_temp), Trials{1, i}.Score, i};
    %     end
    % end
    % desc = [desc, desc2];
    
    %% Write the PC_SB_FB_SP_event.txt file
    % File name
    filename = 'PC_SB_FB_event.txt';
    
    % Open the file for writing
    fileID = fopen(filename, 'w');
    
    % Check if the file was opened successfully
    if fileID == -1
        error('Cannot open file for writing: %s', filename);
    end
    
    % Write the header
    fprintf(fileID, 'type\tlatency\tdesc\n');
    
    % Write the data
    for i = 1:numel(type)
        % Convert the nested cell array in desc to a string with underline separator
        desc_str = strjoin(cellfun(@num2str, desc{i}, 'UniformOutput', false), '_');
        fprintf(fileID, '%s\t%d\t%s\n', type{i}, latency(i), desc_str);
    end
    
    % Close the file
    fclose(fileID);
    
    % Notify the user
    fprintf('File saved successfully: %s\n', filename);
    
    
    %% Add Events to the EEG file 
    [EEG, eventnumbers] = pop_importevent(EEG, 'event', ...
              'PC_SB_FB_event.txt', 'fields', {'type', 'latency','desc' }, ...
              'append', 'no', 'align', NaN, 'skipline', 1, 'timeunit', 1E-3);


    %% individual EEG processing to remove non-exp segments
    % it is stongly recommended to remove these segments because they may contain strong artifacts that confuse channel
    % detection and AMICA
    
    % this example removes everything before the first and after the last event with a buffer of 1 second
    
    allevents = {EEG.event.type}';
    
    removeindices = [0 EEG.event(1).latency-EEG.srate]; % remove from start to first event
    % add more removeIndices here for pauses or itnerruptions of the experiment if they have markers or you know their
    % indices in the data...
    for i = 1:numel(score_press_latency_EEG)-1
        removeindices(i+1, :) = [EEG.event(3*i).latency+50 EEG.event(3*i+1).latency-50];
    end
    removeindices(end+1,:) = [EEG.event(end).latency+EEG.srate EEG.pnts]; % remove from last event to the end
    

    %%
    % filter for plot
    EEG_plot = pop_eegfiltnew(EEG, 'locutoff',0.5, 'hicutoff', 40,'plotfreqz',0);
    
    % plot
    fig1 = figure; set(gcf,'Color','w','InvertHardCopy','off', 'units','normalized','outerposition',[0 0 1 1])
    plot(normalize(EEG_plot.data') + [1:10:10*EEG_plot.nbchan], 'color', [78 165 216]/255)
    yticks([])
    
    xlim([0 EEG.pnts])
    ylim([-10 10*EEG_plot.nbchan+10])
    
    hold on
    
    % plot lines for valid times
    
    for i = 1:size(removeindices,1)
        plot([removeindices(i,1) removeindices(i,1)],ylim,'k', 'LineStyle','-')
        plot([removeindices(i,2) removeindices(i,2)],ylim,'k', 'LineStyle','--')
    end
    title(['Subject ', num2str(subject), ', Non-Exp Segments: From Solid Line to Next Dashed Line on the Right'])
    
    % save plot
    print(gcf,fullfile(input_filepath,[bemobil_config.filename_prefix num2str(subject) '_raw-full_EEG.png']),'-dpng')
    close

    %% Add other events like flexion and extension
    % Important Note: before rejecting the non-exp segments you must add
    % the flexion/Extension start events

    % cd 'C:\Morteza\Analysis\ANSYMB2024\data\Trials_info\sub-7'
    % load('subj_7_Trials_encoder_events.mat')
    % cd 'C:\Morteza\Analysis\ANSYMB2024\Code\data_processing'

    

    %% reject
    % EEG = eeg_eegrej(EEG, removeindices);   
    
    %% processing wrappers for basic processing and AMICA
    
    % do basic preprocessing, line noise removal, and channel interpolation
	[ALLEEG, EEG_preprocessed, CURRENTSET] = bemobil_process_all_EEG_preprocessing(subject, bemobil_config, ALLEEG, EEG, CURRENTSET, force_recompute);

    % start the processing pipeline for AMICA
	bemobil_process_all_AMICA(ALLEEG, EEG_preprocessed, CURRENTSET, subject, bemobil_config, force_recompute);

end

bemobil_copy_plots_in_one(bemobil_config)

subjects
subject

disp('PROCESSING DONE! YOU CAN CLOSE THE WINDOW NOW!')


%% Manual coding for storing the flexion extension epochs and plot the results
% first open the eeglab and load the cleaned version of data.

% open eeglab
% now load the sub-7_cleaned_with_ICA.set file

cd 'C:\Morteza\Analysis\ANSYMB2024\data\Trials_info\sub-7'
load('subj_7_Trials_encoder_events.mat')
cd 'C:\Morteza\Analysis\ANSYMB2024\Code\data_processing'

Trials_encoder_events;

%%
% Define the structure template
structTemplate = ...
    struct('flexion_start_time', [], 'flexion_start_indx', [], ...
    'flexion_end_time', [], 'flexion_end_indx', [], ...
    'extension_start_time', [], 'extension_start_indx', [], ...
    'extension_end_time', [], 'extension_end_indx', [], ...
    'flex_to_flex_start_time', [], 'flex_to_flex_start_indx', [], ...
    'flex_to_flex_end_time', [], 'flex_to_flex_end_indx', []);

% Create a cell array of size 1x10, each containing the structure template
Trials_epochs_events = repmat({structTemplate}, 1, length(Trials_encoder_events));

for i = 1:length(Trials_encoder_events)
    if ~isempty(Trials_encoder_events{1, i}.high_peaks) && ...
            ~isempty(Trials_encoder_events{1, i}.low_peaks)
        flag0 = 1;
        if Trials_encoder_events{1, i}.high_peaks.index(1) > ...
                Trials_encoder_events{1, i}.low_peaks.index(1)  
            
            flag1 = 1;
        else
            flag1 = 0;
        end
    
        if Trials_encoder_events{1, i}.high_peaks.index(end) > ...
                Trials_encoder_events{1, i}.low_peaks.index(end)  
            
            flag2 = 1;
        else
            flag2 = 0;
        end
    else
        flag0 = 0;
    end


    all_types = {EEG.event.type};
    % Find the indices where the type matches 'abc'
    start_beep_indx_on_EEGevent = ...
        find(strcmp(all_types, 'SB_Start_Beep'), i);
    start_beep_latency_on_EEGevent = ...
        EEG.event(start_beep_indx_on_EEGevent(end)).latency;
    start_beep_time_on_EEGtimes = EEG.times(start_beep_latency_on_EEGevent);

    % case 1 
    if flag1 == 1 && flag2 == 1 && flag0 == 1
        % i
        for j = 1:numel(Trials_encoder_events{1, i}.high_peaks.time)-1
            % Flexion start
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
            FlxS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t1 = (FlxS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t1_index_temp] = min(abs(EEG.times - t1));

            Trials_epochs_events{1, i}.flexion_start_indx(end+1, 1) = t1_index_temp;
            Trials_epochs_events{1, i}.flexion_start_time(end+1, 1) = EEG.times(t1_index_temp);

            

            % Flexion end
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j+1)));
            FlxE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t2 = (FlxE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t2_index_temp] = min(abs(EEG.times - t2));

            Trials_epochs_events{1, i}.flexion_end_indx(end+1, 1) = t2_index_temp;
            Trials_epochs_events{1, i}.flexion_end_time(end+1, 1) = EEG.times(t2_index_temp);
    


            % Extension strat
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j+1)));
            ExtS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t3 = (ExtS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t3_index_temp] = min(abs(EEG.times - t3));

            Trials_epochs_events{1, i}.extension_start_indx(end+1, 1) = t3_index_temp;
            Trials_epochs_events{1, i}.extension_start_time(end+1, 1) = EEG.times(t3_index_temp);
            


            % Extension end
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
            ExtE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t4 = (ExtE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t4_index_temp] = min(abs(EEG.times - t4));

            Trials_epochs_events{1, i}.extension_end_indx(end+1, 1) = t4_index_temp;
            Trials_epochs_events{1, i}.extension_end_time(end+1, 1) = EEG.times(t4_index_temp);
        


            % flexion to flexion start
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
            flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t5 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t5_index_temp] = min(abs(EEG.times - t5));

            Trials_epochs_events{1, i}.flex_to_flex_start_indx(end+1, 1) = t5_index_temp;
            Trials_epochs_events{1, i}.flex_to_flex_start_time(end+1, 1) = EEG.times(t5_index_temp);
        


            % flexion to flexion end
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
            flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t6 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t6_index_temp] = min(abs(EEG.times - t6));

            Trials_epochs_events{1, i}.flex_to_flex_end_indx(end+1, 1) = t6_index_temp;
            Trials_epochs_events{1, i}.flex_to_flex_end_time(end+1, 1) = EEG.times(t6_index_temp);
        
        end
    end


    % _____________________________


    % case 2
    if flag1 == 1 && flag2 == 0 && flag0 == 1
        % i
        for j = 1:numel(Trials_encoder_events{1, i}.high_peaks.time)
            % Flexion start
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
            FlxS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t1 = (FlxS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t1_index_temp] = min(abs(EEG.times - t1));

            Trials_epochs_events{1, i}.flexion_start_indx(end+1, 1) = t1_index_temp;
            Trials_epochs_events{1, i}.flexion_start_time(end+1, 1) = EEG.times(t1_index_temp);

            

            % Flexion end
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j+1)));
            FlxE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t2 = (FlxE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t2_index_temp] = min(abs(EEG.times - t2));

            Trials_epochs_events{1, i}.flexion_end_indx(end+1, 1) = t2_index_temp;
            Trials_epochs_events{1, i}.flexion_end_time(end+1, 1) = EEG.times(t2_index_temp);
    


            % Extension strat
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j+1)));
                ExtS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t3 = (ExtS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t3_index_temp] = min(abs(EEG.times - t3));
    
                Trials_epochs_events{1, i}.extension_start_indx(end+1, 1) = t3_index_temp;
                Trials_epochs_events{1, i}.extension_start_time(end+1, 1) = EEG.times(t3_index_temp);
            end


            % Extension end
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
                ExtE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t4 = (ExtE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t4_index_temp] = min(abs(EEG.times - t4));
    
                Trials_epochs_events{1, i}.extension_end_indx(end+1, 1) = t4_index_temp;
                Trials_epochs_events{1, i}.extension_end_time(end+1, 1) = EEG.times(t4_index_temp);
            end


            % flexion to flexion start
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
                flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t5 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t5_index_temp] = min(abs(EEG.times - t5));
    
                Trials_epochs_events{1, i}.flex_to_flex_start_indx(end+1, 1) = t5_index_temp;
                Trials_epochs_events{1, i}.flex_to_flex_start_time(end+1, 1) = EEG.times(t5_index_temp);
            end


            % flexion to flexion end
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
                flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t6 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t6_index_temp] = min(abs(EEG.times - t6));
    
                Trials_epochs_events{1, i}.flex_to_flex_end_indx(end+1, 1) = t6_index_temp;
                Trials_epochs_events{1, i}.flex_to_flex_end_time(end+1, 1) = EEG.times(t6_index_temp);
            end

        end
    end


    % _____________________________


    % case 3
    if flag1 == 0 && flag2 == 1 && flag0 == 1
        % i
        for j = 1:numel(Trials_encoder_events{1, i}.high_peaks.time)-1
            % Flexion start
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
            FlxS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t1 = (FlxS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t1_index_temp] = min(abs(EEG.times - t1));

            Trials_epochs_events{1, i}.flexion_start_indx(end+1, 1) = t1_index_temp;
            Trials_epochs_events{1, i}.flexion_start_time(end+1, 1) = EEG.times(t1_index_temp);

            

            % Flexion end
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j)));
            FlxE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t2 = (FlxE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t2_index_temp] = min(abs(EEG.times - t2));

            Trials_epochs_events{1, i}.flexion_end_indx(end+1, 1) = t2_index_temp;
            Trials_epochs_events{1, i}.flexion_end_time(end+1, 1) = EEG.times(t2_index_temp);
    


            % Extension strat
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j)));
                ExtS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t3 = (ExtS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t3_index_temp] = min(abs(EEG.times - t3));
    
                Trials_epochs_events{1, i}.extension_start_indx(end+1, 1) = t3_index_temp;
                Trials_epochs_events{1, i}.extension_start_time(end+1, 1) = EEG.times(t3_index_temp);
            end


            % Extension end
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
                ExtE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t4 = (ExtE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t4_index_temp] = min(abs(EEG.times - t4));
    
                Trials_epochs_events{1, i}.extension_end_indx(end+1, 1) = t4_index_temp;
                Trials_epochs_events{1, i}.extension_end_time(end+1, 1) = EEG.times(t4_index_temp);
            end


            % flexion to flexion start
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
                flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t5 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t5_index_temp] = min(abs(EEG.times - t5));
    
                Trials_epochs_events{1, i}.flex_to_flex_start_indx(end+1, 1) = t5_index_temp;
                Trials_epochs_events{1, i}.flex_to_flex_start_time(end+1, 1) = EEG.times(t5_index_temp);
            end


            % flexion to flexion end
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
                flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t6 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t6_index_temp] = min(abs(EEG.times - t6));
    
                Trials_epochs_events{1, i}.flex_to_flex_end_indx(end+1, 1) = t6_index_temp;
                Trials_epochs_events{1, i}.flex_to_flex_end_time(end+1, 1) = EEG.times(t6_index_temp);
            end

        end
    end



    % _____________________________
   


    % case 4
    if flag1 == 0 && flag2 == 0 && flag0 == 1
        i
        for j = 1:numel(Trials_encoder_events{1, i}.high_peaks.time)
            % Flexion start
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
                FlxS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t1 = (FlxS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t1_index_temp] = min(abs(EEG.times - t1));
    
                Trials_epochs_events{1, i}.flexion_start_indx(end+1, 1) = t1_index_temp;
                Trials_epochs_events{1, i}.flexion_start_time(end+1, 1) = EEG.times(t1_index_temp);
            end
            

            % Flexion end
            [~, indx_in_All_EEG_time] = ...
                min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j)));
            FlxE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
            
            t2 = (FlxE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
            [~, t2_index_temp] = min(abs(EEG.times - t2));

            Trials_epochs_events{1, i}.flexion_end_indx(end+1, 1) = t2_index_temp;
            Trials_epochs_events{1, i}.flexion_end_time(end+1, 1) = EEG.times(t2_index_temp);
    


            % Extension strat
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.low_peaks.time(j)));
                ExtS_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t3 = (ExtS_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t3_index_temp] = min(abs(EEG.times - t3));
    
                Trials_epochs_events{1, i}.extension_start_indx(end+1, 1) = t3_index_temp;
                Trials_epochs_events{1, i}.extension_start_time(end+1, 1) = EEG.times(t3_index_temp);
            end


            % Extension end
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
                ExtE_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t4 = (ExtE_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t4_index_temp] = min(abs(EEG.times - t4));
    
                Trials_epochs_events{1, i}.extension_end_indx(end+1, 1) = t4_index_temp;
                Trials_epochs_events{1, i}.extension_end_time(end+1, 1) = EEG.times(t4_index_temp);
            end


            % flexion to flexion start
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j)));
                flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t5 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t5_index_temp] = min(abs(EEG.times - t5));
    
                Trials_epochs_events{1, i}.flex_to_flex_start_indx(end+1, 1) = t5_index_temp;
                Trials_epochs_events{1, i}.flex_to_flex_start_time(end+1, 1) = EEG.times(t5_index_temp);
            end


            % flexion to flexion end
            if j < numel(Trials_encoder_events{1, i}.high_peaks.time)
                [~, indx_in_All_EEG_time] = ...
                    min(abs(All_EEG_time - Trials_encoder_events{1, i}.high_peaks.time(j+1)));
                flextoflex_in_All_EEG_time = All_EEG_time(indx_in_All_EEG_time);
                
                t6 = (flextoflex_in_All_EEG_time - All_EEG_time(start_beep_indx_EEG(i)))*1000 + start_beep_time_on_EEGtimes;                
                [~, t6_index_temp] = min(abs(EEG.times - t6));
    
                Trials_epochs_events{1, i}.flex_to_flex_end_indx(end+1, 1) = t6_index_temp;
                Trials_epochs_events{1, i}.flex_to_flex_end_time(end+1, 1) = EEG.times(t6_index_temp);
            end

        end
    end
    


end
